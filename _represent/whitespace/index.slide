Whitespace処理系をGo言語で実装してみた
@snowcrush

@snowcrush

* 素振り
GoConのLTに応募したので素振りさせてくださいー

書いてて思ったが素振りって野球エンジニア用語では・・・

* 動機 

https://www.ipa.go.jp/sec/reports/20180306.html
.image ipa.png _ 600


* SLOC !!
> brainfuckとかwhitespaceみたいな感じで改行文字のみで
> プログラミングする言語作ると生産性めっちゃあがるんじゃねーかな

みたいなことを某所に書いた。

* じゃあ実際に作ってみよう

**
*そもそもWhitespaceのタブかスペースを"\r"に変えればよくね？*
** 
*→_まずWhitespace作ってみよう*

* Whitespace
- Esolang（難解プログラミング言語）の一つ
- 空白、タブ、ラインフィードの三文字だけでプログラムを記述できる
- 以下空白をS、"\t"をT、LFを"L"と置き換えたソースコード
  SS STSL # push 2 to stack
  LS # duplicate top of the stack
  TSSS # sum top 2 of the stack
  TLST # print top of the stack
  => 4

* 仕様
まずWhitespaceの本家が無くなっていた。
検索して以下のページを見つけたのでそれを参考に仕様を書き出した。

.link http://koturn.hatenablog.com/entry/2015/08/10/000000

実装はここでruby版の実装を主に参考にした。
でも大体命令リストだけで作れたのであんまり読んでないです。
.link https://github.com/hostilefork/whitespacers

あとWebarchiveで検索して本家からHaskell版のソースコードのアーカイブを取得

* 命令
Whitespaceのコードは命令と引数に大別される。
ドキュメントによっては命令はIMPとCommandにさらに分割されると書いてあるが、
実装上分ける意味はあまりない。

命令は以下に大別される。

- スタック操作
- 演算
- ヒープ操作
- ラベル操作、ジャンプ命令
- IO操作

* 引数
引数を取る命令に続く文字列は引数として解釈される。
引数の終わりはLFで、LFに達するまでのタブと空白がそれぞれ正負のビットとして解釈される。
つまり一つの引数はビット列である。

引数は数値型かラベルである。

- 数値型は、最初の1ビットが正負を表し、残りのビット列を数値として解釈する。
- ラベルはビット列をそのまま一意の識別子として解釈する。

* コメント
空白、タブ、LFを除く全ての文字はコメントである。

* パーサ
パーサは簡易的なステートマシンとして実装した。

- S_START 命令の読み取り開始
- S_READ_PARAM 引数の読み取り開始
- S_S 空白文字一文字読み取った状態
_ ST  空白とタブ文字を読み取った状態

switch文を二重に書いて、現在のステートと読み取ったバイトによって次のステートを決定する。
命令の読み取りが完了した場合、
引数がなければそのまま、引数があればLFを読み取るまで引数を読んだあと、
命令オブジェクトをリストに追加する。

* 命令オブジェクト
.code command.go

上記インターフェースを満たす構造体を命令ごとに作成した。
AddBitToParamとFinishReadParamは引数の読み取りに使う。
Execは命令ごとの処理をランタイムに対して行う。

* ラベル
命令の場所を覚えておくための識別子（ビット列）。
パーサ読み取り時に*ラベル=>命令オブジェクトのindex*がマップとして作成される。
ラベル定義命令（LSS）で定義する（パース時に作成されるためこの命令は何もしない）。
ジャンプ命令(LSL)でラベルにジャンプすることができる。

* ランタイム
ランタイムは以下の構造体である。
.code runtime.go

- stackはint型のスタックである（実体は配列）
- heapは数値型=>数値型のマップである
- labelsはラベル=>行番号のマップである（ジャンプに使う）
- callstack は行番号のスタックである
- indexはランタイムが実行している命令オブジェクトのindexである

* 実行
- ループでRuntime.indexを一つずつインクリメントし、順に命令オブジェクトを実行していく
- 基本的にスタックに値を積んでそれを演算する
- プログラム内のループや分岐、gotoはindexにラベルに対応する行番号をセットすることで表現する
- 関数はサブルーチン命令というのがあってコールスタックに呼び出し位置を覚えておくことができる

以上!

* 結果

- 一応完成した
.link https://github.com/minoritea/whitespace

- テストコードみたいなのが無いので（本家がロストしたので）、仕様を満たしているかは不明
- Haskellソース付属のサンプルコードはだいたい動いた

* 感想

- 言語仕様はすげーシンプルなので愚直に実装すればよかった
- ソースが読めないのでデバッグしんどい => ソースの変換コマンドも作った  
- 行の概念がないのでデバッグしんどい...

- Goで実装したのは初めてだろうと思っていたら先行者がすでに沢山いた・・・
.link https://github.com/technohippy/go-whitespace
.link https://github.com/135yshr/wspacego
.link https://github.com/mattn/ujihisa

- ググラビリティ低い言語名2つのコンビネーション技こわい
