<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on フリーランチなど無い - There ain&#39;t no such thing as a free lunch</title>
    <link>https://tanstaafl.0pt.jp/tags/docker/index.xml</link>
    <description>Recent content in Docker on フリーランチなど無い - There ain&#39;t no such thing as a free lunch</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <atom:link href="/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SystemdでDocker上のPostgreSQLをバックアップする</title>
      <link>https://tanstaafl.0pt.jp/posts/2014/12/09/15cb34942165/</link>
      <pubDate>Tue, 09 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tanstaafl.0pt.jp/posts/2014/12/09/15cb34942165/</guid>
      <description>&lt;p&gt;先日書いた、&lt;a href=&#34;https://tanstaafl.0pt.jp/posts/2014/12/06/8fc4abc5b442&#34;&gt;CoreOSでバックアップを取っていなかったためデータを飛ばした話&lt;/a&gt;の続きである。&lt;/p&gt;

&lt;p&gt;前回fleetを使うという話をしたのだけれど、自分が今使っている環境はシングルホストだしsystemdを使うことにした。最もfleetはsystemdを分散クラスタ上で管理するためのツールのようなので、実際やることは変わらないだろう。&lt;/p&gt;

&lt;p&gt;まず、Postgresからデータを取り出すためのイメージを作った。中身は単純にPostgres公式イメージ上でpg_dumpを実行するだけのシロモノである。
dumpしたファイルは volumeとして取り込んだホスト側の領域に吐き出される。
上記イメージを実行するコマンドをシェルスクリプトでラップし、実行ファイルとした。&lt;/p&gt;

&lt;p&gt;pg-backup.sh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BACKUP_DIR=バックアップファイル置き場
docker run --rm -ti --link -v $BACKUP_DIR:/var/pg_dump \
  my-postgres-container:pg postgres-backup-image
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にこのスクリプトをsystemdのサービスとして登録する。
systemdではユニットという単位でOS上の様々なものを管理する。
サービスもユニットの一種という扱いのようだ。
これらのユニットを管理するための設定ファイルとしてユニットファイルを書くとsystemd側でロード、起動を実行してくれる。
ユニットファイルはCoreOSのデフォルトだと、/etc/systemd/systemに置く。
上のスクリプトのユニットファイルは以下のようになる。&lt;/p&gt;

&lt;p&gt;pg-dump.service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=Dump data from Postgres container
Requires=docker.service

[Service]
ExecStart=/opt/docker/scripts/pg-backup/pg-backup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Descriptionはユニットの説明を、Requiresは依存関係（この場合dockerサービス）を表している。
ExecStartには実際に実行されるコマンドを置く。&lt;/p&gt;

&lt;p&gt;次に、ジョブスケジューリングのためのユニットファイルを書く。systemdではタイマーイベントもユニットとして扱うことが出来る。&lt;/p&gt;

&lt;p&gt;pg-dump.timer&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=daily Postgres backup

[Timer]
OnCalendar=*-*-* 20:00:00

[Install]
WantedBy=default.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OnCalendarで起動時刻を指定する。この辺りはCronとおなじ感覚だ。
&lt;em&gt;.serviceと&lt;/em&gt;.timerが同じ名前であれば、起動するサービス名は指定しなくてよい。&lt;/p&gt;

&lt;p&gt;あとは&lt;code&gt;sudo systemctl start pg-backup.timer&lt;/code&gt;で実行すれば、タイマーイベントとして登録される。&lt;/p&gt;

&lt;p&gt;タスクスケジューラとしてsystemdを使ってみた感想としては、最初の印象ほどややこしくはなかったが、このぐらいのタスクであればcronの方が楽かもしれない。
依存関係などを考えるようになると真価を発揮するのではないかと思っている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CoreOSつかってたらデータが飛んだ</title>
      <link>https://tanstaafl.0pt.jp/posts/2014/12/06/8fc4abc5b442/</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tanstaafl.0pt.jp/posts/2014/12/06/8fc4abc5b442/</guid>
      <description>&lt;p&gt;DBのデータが飛んだので先日書いたReactについての記事は下書きから復元した。&lt;/p&gt;

&lt;p&gt;原因はCoreOSが自動アップデートしたため、Postgresを動かしていたDockerコンテナが停止してしまったためだ。&lt;/p&gt;

&lt;p&gt;実は先日こっそりとブログのサーバーをherokuからVPSに移動していた
（Dockerで運用してみたかったのだ）。OSはCoreOSを使いホスティングはVultrを選択した。&lt;/p&gt;

&lt;p&gt;移行の際、データベースもDockerで動かすことにしていた。PostgreSQLでデータベースコンテナを作成していたのだけれど、バックアップの仕組みはつい後回しにしていたのだ。&lt;/p&gt;

&lt;p&gt;しかし間の悪いことについ昨日CoreOS（stable）のアップデートが入ってしまった。自分は知らずに運用していたのだがCoreOSはOSアップデートを自動で適用し、デフォルトだとそのまま再起動してしまう。そのためデータベースもコンテナごと落ちてしまいデータが飛んでしまったのだ。自動アップデート&amp;amp;OS再起動は、Immutableなコンテナを分散して運用する前提での設定だと思うのだがシングルホストだとあんまり美味しくない。とはいえ、セキュリティ面では自動アップデート戦略は安心感があるし、個人ブログのホスティングサーバが多少の時間落ちていても大して困らないのでこのままデフォルト設定で行くことにする。&lt;/p&gt;

&lt;p&gt;さて再起動しても自動で復旧するにはコンテナのデータを永続化することとコンテナの起動を自動化することの2つが必要となる。取り急ぎ今回は永続化について対応してみた。&lt;/p&gt;

&lt;p&gt;永続化といってもpg_dumpで定期的にdumpを取るだけである（自分がPostgresの運用の知識がないのでもっといいやり方があるのかもしれないけど、データ量も少ないしシンプルなので上のやりかたでいく）。dumpファイルはDockerのvolume機能を使ってホストOS上に置くことにする。&lt;/p&gt;

&lt;p&gt;とりあえず、現在はdumpするスクリプトだけ作成してある。しかし手動実行はつらいので自動で定期的に回すようにしたい。定期的に実行する手段としては、コンテナの中でcronを回すか、専用のコンテナを作って、fleetで定期的に起動するかのどちらかを考えている。&lt;/p&gt;

&lt;p&gt;fleetはCoreOSの主要な機能の一つで、systemdを分散してスケジューリング、実行するためのミドルウェアのようだ。自分はsystemdの知識があまりないのでcronでもよいかと思ったのだが（systemdにタスクスケジューラの機能があることも知らなかった）、せっかくCoreOSを使っているのでfleet/systemd を使う方向で考えたいと思う。&lt;/p&gt;

&lt;p&gt;自動復旧のためのコンテナ起動についてもfleetを使えば良さそうだ。&lt;/p&gt;

&lt;p&gt;またうまく仕組み化できたら報告したい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dokkuでgit pushするとfatalしてハマった</title>
      <link>https://tanstaafl.0pt.jp/posts/2014/05/10/7dd28c8c4515/</link>
      <pubDate>Sat, 10 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tanstaafl.0pt.jp/posts/2014/05/10/7dd28c8c4515/</guid>
      <description>&lt;p&gt;最近herokuからdockerベースの環境に乗り換えようと思って、とりあえずdokkuを試している。&lt;/p&gt;

&lt;p&gt;dokkuでマニュアル通り作成したのだが、以下の様なエラーが出てどうにもならなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fatal: &#39;hogehoge.git&#39; does not appear to be a git repository
fatal: Could not read from remote repository.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いろいろ試行錯誤した結果、実に単純に解決した。
~/.ssh/authorized_keys に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command=&amp;quot;...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような行が追加されている。
これは設定時に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub | ssh progriumapp.com &amp;quot;sudo sshcommand acl-add dokku progrium&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というコマンドでアクセス権限を追加された際自動で挿入されたものだが、その上に手動で自分の公開鍵を挿入していたために、どうやらgit pushが動かなかったらしい。&lt;/p&gt;

&lt;p&gt;手で追加した方の公開鍵を削除したら無事解決した。&lt;/p&gt;

&lt;p&gt;素直にマニュアル通りに作ればこういうことにはならないので、同様にハマる人は少ないかもしれないが一応載せておく。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
