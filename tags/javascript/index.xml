<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on フリーランチなど無い - There ain&#39;t no such thing as a free lunch</title>
    <link>http://tanstaafl.0pt.jp/tags/javascript/</link>
    <description>Recent content in Javascript on フリーランチなど無い - There ain&#39;t no such thing as a free lunch</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 19 Nov 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://tanstaafl.0pt.jp/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ReactRubyをリリースした。</title>
      <link>http://tanstaafl.0pt.jp/posts/2014/11/19/b22b24ca7ea5/</link>
      <pubDate>Wed, 19 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2014/11/19/b22b24ca7ea5/</guid>
      <description>&lt;p&gt;先日、&lt;a href=&#34;http://facebook.github.io/react/&#34;&gt;React&lt;/a&gt; をテンプレートとして使えるRubyライブラリの &lt;a href=&#34;https://github.com/minoritea/react_ruby&#34;&gt;ReactRuby&lt;/a&gt; をリリースした。&lt;/p&gt;

&lt;p&gt;このブログは自作のブログエンジンで動いていて、気が向くたびに作りなおしている。何か使いたい技術やライブラリがあって試してみたいというとき、ブログエンジンというのは結構良い題材だと思っていて、実際今までもNode.jsを使ったりAngularJSを使ったりしてきた。&lt;/p&gt;

&lt;p&gt;今回はFacebook製のコンポーネントフレームワークであるReactを使って、フロントエンドを作成しようと思い立った。Reactを選んだ理由として、Angularだとサーバーサイドでビューを生成できないので不満に思っていたことが挙げられる。&lt;/p&gt;

&lt;p&gt;今まで、コンテンツページに関してはHAMLを使ってサーバサイドで生成していて、Angularのテンプレートキャッシュを使って読み込んでいたのだが、これだとフロントサイドでビュー生成している意味が薄くていまいち不満だったのだ（この実装だとやってることはまんまTurbolinksである）。&lt;/p&gt;

&lt;p&gt;ReactはHTMLを文字列として出力できる。つまりサーバサイドでも実行可能なテンプレートエンジンとして使えるということである。ReactはjavascriptなのでNode.jsあたりで動かすのが適切なんだろうけど、今回サーバサイドは既存のアプリを使いまわしたかったのでRubyでReactを呼び出すためのブリッジを作成した。それがReactRubyである。（React本家にはRailsのバインディングがあったが、まだ安定版が出てなかったし今回サーバサイドに使ったのはSinatraだったので自作した）。&lt;/p&gt;

&lt;p&gt;使い方はシンプルに、テンプレートを文字列として渡してコンパイルし、呼び出したいクラスのXMLタグを#renderメソッドに渡してやればよい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ReactRuby.compile(jsx: your_jsx_template_as_string)
ReactRuby.render(&amp;quot;&amp;lt;YourJSXClass /&amp;gt;&amp;quot;)
# =&amp;gt; YourJSXClassのレンダリング結果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自分はこの処理をsinatraのヘルパーメソッドとして定義して、sinatraのビューの中でコンポーネント単位で呼び出している。1度サーバから画面を読み込んだら、あとの画面更新は画面上でReactを再実行してレンダリングしなおしている。流行りの&amp;rdquo;Isomorphic&amp;rdquo;アプリケーションというやつだ（正確にはビューだけのなんちゃってIsomorphicなんだけど、このブログくらいの小さいアプリなら十分だと思う）。&lt;/p&gt;

&lt;p&gt;ReactRubyはgemとして公開してあるので、この記事を読んで興味をもった方は是非試してほしい。簡単なサンプルアプリもgithubにおいてあるので参考にどうぞ（&lt;a href=&#34;https://github.com/minoritea/react_ruby_sample&#34;&gt;react_ruby_sample&lt;/a&gt;）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AngularJSでチェックボックスとモデルを紐付ける</title>
      <link>http://tanstaafl.0pt.jp/posts/2014/04/16/b5d918640be9/</link>
      <pubDate>Wed, 16 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2014/04/16/b5d918640be9/</guid>
      <description>&lt;p&gt;AngularJSを使ったフォームでチェックボックスを使いたいとする。
このとき単に真偽値を取りたいのであればそのままモデルを設定すれば、checkboxの値（true/false）をモデルに紐付けることが出来る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; ng-model=&amp;quot;model&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし真偽値以外の値をモデルに設定したい場合もある。
その場合には&lt;code&gt;ngTrue&lt;/code&gt;, &lt;code&gt;ngFalse&lt;/code&gt;ディレクティブを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; ng-model=&amp;quot;model&amp;quot; ng-true=&amp;quot;OK&amp;quot; ng-false=&amp;quot;Fail&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の例だとチェックが入っていればモデルの値は&lt;code&gt;&amp;quot;OK&amp;quot;&lt;/code&gt;に、入ってなければ&lt;code&gt;&amp;quot;Fail&amp;quot;&lt;/code&gt;にそれぞれ設定される。&lt;/p&gt;

&lt;p&gt;ただし、これらの紐付けはモデルに対して行われる。つまり、モデルの変更がチェックボックス側に伝達されるわけではない。これはHTMLの仕様によるらしいが、自分の理解では&lt;code&gt;checked&lt;/code&gt;属性のような真偽値を持つ属性が偽になった時、ブラウザ側で値が保持されないため、AngularJSのバインディングが切れてしまうことによるようだ。&lt;/p&gt;

&lt;p&gt;そのためモデル側の変更に合わせてチェックボックスのチェックを付け外ししたい場合は&lt;code&gt;ngChecked&lt;/code&gt;ディレクティブを使う必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;checkbox&amp;quot; ng-model=&amp;quot;model&amp;quot; ng-checked=&amp;quot;model&amp;quot; /&amp;gt;
...
function CheckBoxController($scope){
  $scope.model = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のようにすれば、$scope.modelが設定されたタイミングでチェックボックス側のチェックも自動で入れることが出来る。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1ページAppでクローラに動的なメタ情報を読ませることが出来るか？</title>
      <link>http://tanstaafl.0pt.jp/posts/2014/04/04/9ca958c064f2/</link>
      <pubDate>Fri, 04 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2014/04/04/9ca958c064f2/</guid>
      <description>&lt;p&gt;このブログは1ページAppを目指して作っている（まだ完成していないがいずれは少数の静的ページに集約したいと思っている）。1ページAppはシングルページアプリケーション（SPA）とも言い、1ページのHTMLページ内で動的にコンテンツを切り替えていくアプリのことだ。
URLのパラメータやフラグメントを元に、Ajaxなどで動的にコンテンツをロードすることであたかもそれぞれのページが存在するかのように別々のコンテンツを表示する。&lt;/p&gt;

&lt;p&gt;ここで問題になるのは、Googleなどのクローラはjavascriptを実行しないため、クローラに対してTitleタグやOGPなどのメタ情報をクライアント側で動的に出し分けることが出来ないということだ。これについて何か解決策がないか調べてみたのだが、結論としては、クローラなどにjavascrptで動的にメタ情報を付加することはやっぱり出来ないということだった。（そりゃそうだ）。&lt;/p&gt;

&lt;p&gt;特に参考になったのは以下の記事である。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://coderwall.com/p/vqpfka&#34;&gt;AngularJS SEO&lt;/a&gt; &lt;a href=&#34;https://coderwall.com/p/vqpfka&#34;&gt;https://coderwall.com/p/vqpfka&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この記事では2つの解法が示されている。&lt;/p&gt;

&lt;p&gt;1つ目はシンプルに&lt;strong&gt;そもそも1ページAppにはしない&lt;/strong&gt;こと。
実はこのブログではこちらの解法を採用するつもりだ。各記事についてはサーバ側のテンプレートを分けて、そちらにはメタ情報をサーバ側で付与する。1ページに集約することにこだわるより、AngularJSのテンプレートを使って再利用できるところは再利用し、最低限のサーバ側で出しわけないといけないところはサーバ側でレンダリングする方が自然だと判断したからだ。とはいえ1ページAppというのはロマンがあったので少し残念ではある。&lt;/p&gt;

&lt;p&gt;2つ目のやり方はサーバ側でHTMLページをレンダリングし、クローラに表示することだ。
これをわざわざやってまでSEO対策するほどのメリットは見いだせなかったのでこちらの手段は取らないことにした。
上の記事では2つ目のやり方について詳しく書かれているが、&lt;strong&gt;滅茶苦茶めんどくさそう&lt;/strong&gt;な印象を受けたからだ。&lt;/p&gt;

&lt;p&gt;そういうわけで結論としては1ページAppでメタ情報を動的に扱うのは基本的に無理筋だということがわかった。（身も蓋もないが）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JSONとJSONPの違い</title>
      <link>http://tanstaafl.0pt.jp/posts/2010/11/17/75eb52a3779e/</link>
      <pubDate>Wed, 17 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2010/11/17/75eb52a3779e/</guid>
      <description>&lt;p&gt;Twitter APIで取得していたコメントが消えてしまった。Twitter検索で引っかかるのは7日間だけである。これでは少し寂しいのでツイートの取得にTopsyを利用してみた。Topsyはツイッター等の発言をベースにした検索エンジンで、公開されたAPIから特定のサイトについてのツイートを抽出して取得するといったことが出来る。&lt;/p&gt;

&lt;p&gt;それでTopsyのAPIをjQueryの機能で取得してみようとしたのだがjsonを取得しようとするとリクエストは200 OKを返すのにデータが取得出来ない。jQueryが原因かと思って色々調べてみたのだが違うようだ。原因はスクリプトの実行元と異なるドメインのデータをxmlHttpRequestでは取得出来ないかららしい。何故このようにしているかというとクロスサイトスクリプティングを防止するためのようだ。しかしこの制限にも抜け道がある。それがJSONPである。&lt;/p&gt;

&lt;p&gt;JSONPはscriptタグを利用してリモートのデータを読み込む。JSONの実体がjavascriptのコードであることを利用しているのだ。そしてコールバックを実行してデータを再生する。シンプルな仕組みである。&lt;/p&gt;

&lt;p&gt;参考にしたのはここのサイトである（jQueryはJSONPの理解の妨げになるか？）。
僕は今までJSONとJSONPについて違いがよくわかっておらず、単にコールバックを指定するのがJSONPだと思っていた。しかしAjaxの処理にはデータ形式によらずコールバックを使うのだからこれでは違いにならない。scriptタグを利用したデータの読み込みこそがJSONPだったのだ。こういうことはjQueryの解説サイトにはあんまり書いていない。Ajax技術としては常識なんだろうけどjQueryでAjaxを始めた人のためにも是非啓蒙して欲しいと思う。&lt;/p&gt;

&lt;p&gt;まとめ&lt;/p&gt;

&lt;p&gt;JSONを含め通常Ajaxで使うxmlHttpRequestでは外部サイトのデータを取得出来ない(XSS対策）
JSONPはscriptタグで外部サイトを読み込むことで上記を回避している
jQueryではJSONとJSONPを同じように扱えるが両者はまったく由来の異なる技術である。&lt;/p&gt;

&lt;p&gt;JSONはただのデータ形式（javascriptのオブジェクトをtext化したもの）
JSONPはデータを読み込むための技術（javascriptコードの読み込み）&lt;/p&gt;

&lt;p&gt;Ajaxではデータの受け渡しの形式としてどちらも用いられている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Twitterでコメント</title>
      <link>http://tanstaafl.0pt.jp/posts/2010/11/08/1db91739f81f/</link>
      <pubDate>Mon, 08 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2010/11/08/1db91739f81f/</guid>
      <description>&lt;p&gt;Disqusを止めて、コメントシステムをTwitterで管理するようにした。理由は出来る限りシンプルにしたかったことと、Twitter APIを試してみたかったためである。&lt;/p&gt;

&lt;p&gt;ただし、現状コメント機能は無いので外部でつぶやかれたURLをトラックバックするだけの機能である。&lt;/p&gt;

&lt;p&gt;追記：とりあえず、Twitter公式のボタンを挿入した。シンプルでよし。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Twitterでコメント2</title>
      <link>http://tanstaafl.0pt.jp/posts/2010/11/08/ec3b981577bc/</link>
      <pubDate>Mon, 08 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2010/11/08/ec3b981577bc/</guid>
      <description>&lt;p&gt;前回作ったコメントシステムだがコードは単純だ。TwitterのSearch APIをjQuery.ajaxで叩くだけだ。
戻り値はjsonなので処理も簡単に出来る。ハマったのはcallbackを指定しないとjsonが取れないということだ。APIの説明を読んでもOptionalだと書いてあるのだが、どうも必須なようなので取りあえず空で指定してある。取得するコードは以下でjsonを取得したあとはjQueryを使ってHTMLに挿入している。&lt;/p&gt;

&lt;p&gt;var thisurl = encodeURI(encodeURI(decodeURI(window.location.href)));
$.ajax({
  url :&amp;ldquo;&lt;a href=&#34;http://search.twitter.com/search.json&amp;quot;&#34;&gt;http://search.twitter.com/search.json&amp;quot;&lt;/a&gt;,
  dataType : &amp;ldquo;json&amp;rdquo;,
  data : &amp;ldquo;callback=?&amp;amp;q=&amp;ldquo;+thisurl+&amp;rdquo;&amp;amp;show_user=false&amp;rdquo;,
  success : function(json){
  //表示処理
  }
})&lt;/p&gt;

&lt;p&gt;Tweetボタンはここから貼付けた。自動生成で簡単にスクリプトが出来る。
シンプルだがこのブログには十分だろう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SafariのLocationエンコードについて2</title>
      <link>http://tanstaafl.0pt.jp/posts/2010/11/05/a0afd3acb280/</link>
      <pubDate>Fri, 05 Nov 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2010/11/05/a0afd3acb280/</guid>
      <description>&lt;p&gt;前回、SafariでエスケープされたURLのサイトを表示したときに、location.hrefでアドレスを取得するとデコードした文字列が取得されてしまう問題について、webkitのブラウザを判別するスクリプトを書いて対応した。
その後、ChromeだとURLがきちんとエスケープされて取得されることが分かった。僕はchromeは普段使わないのでこの仕様の違いに気付かなかったのである。&lt;/p&gt;

&lt;p&gt;どうやって判別するか悩んでいたのだが、結局decodeURLでエスケープされていないURLをデコードしても結果が変わらないことに着目して以下の対応とした。&lt;/p&gt;

&lt;p&gt;var disqus_url = encodeURI(decodeURI(window.location.href));&lt;/p&gt;

&lt;p&gt;エンコードされたURL（Firefox,Chrome,etc）だけがdecodeURIされ、その後再びencodeURIされるので正しくエスケープされたURLが取得出来る。
URLの下位パスをタイトルから生成していたのでこのような問題となったのだから、そこを改めた方がよいのかもしれない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SafariのLocationエンコードについて</title>
      <link>http://tanstaafl.0pt.jp/posts/2010/10/31/18ea9bf6b0bc/</link>
      <pubDate>Sun, 31 Oct 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tanstaafl.0pt.jp/posts/2010/10/31/18ea9bf6b0bc/</guid>
      <description>&lt;p&gt;やっぱりDisqusがSafariでうまく動作しない。どうも記事ごとにうまく読み込めるかエラーを起こすが決まっているようなので調べるとうまく動作しないのはタイトルがマルチバイトの記事だけだった。&lt;/p&gt;

&lt;p&gt;このブログの各記事のリンクは全てURLをエスケープしてあるのだが、Safariでwindow.location.hrefを取得するとエスケープ前のURLになってしまうのがエラーの原因であるようだ。ちなみにFirefoxでは再現しない。何故このような仕様になっているのか理解に苦しむのだがご存知の方がいたら教えてもらいたい。（バグなんだろうか）。&lt;/p&gt;

&lt;p&gt;ちなみに以下のコードを埋め込むことで一応Safariでのエラーは無くなった。あまりスマートなコードではないが仕方が無い。&lt;/p&gt;

&lt;p&gt;if(!jQuery.support.checkOn){
  var disqus_url = encodeURI(window.location.href);
}&lt;/p&gt;

&lt;p&gt;ちなみにjQueryでのブラウザ判別については「jQuery.supportでのブラウザ判別」を参照した。分かりやすいまとめで助かった。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
